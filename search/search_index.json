{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindos \u00e0 Saturn Wiki Seja bem vindo \u00e0 documenta\u00e7\u00e3o do Saturn-GL em portugu\u00eas, a seguir veja alguns exemplos de c\u00f3digo. Fique \u00e0 vontade para alterar e rodar os exemplos encontrados nas caixas interativas de c\u00f3digo abaixo: Uma pequena bolinha rosa: createCodeBlock('divcode1','1', `Circle circle = CircleBuilder.aCircle() .withCenter(100, 500) .withColor(new Color(200,0,200)) .build(); add(circle); circle.move(500,0,seconds(3)).execute();` ); Uma explos\u00e3o: neste exemplo 100 circulos s\u00e3o criados e enviados a partir do centro da tela em dire\u00e7\u00e3o as extremidades s\u00e3o criadas por tanto, 100 tasks s\u00e3o criadas, uma para cada bolinha. createCodeBlock('divcode2','2', `for (int i = 0; i < 100; i++) { Circle circle = CircleBuilder.aCircle() .withCenter(500, 500) .withColor(Color.white) .withRadius(20) .build(); add(circle); var ang = Math.random() * 6.28; var distance = Math.random() * 400; circle.move(distance * Math.cos(ang), distance * Math.sin(ang), seconds(3)) .parallel(wait(seconds(1.5)).andThen(circle.changeColor(new Color(0, 0, 0, 0)))) .executeInBackGround(); }` );","title":"Home"},{"location":"#bem-vindos-a-saturn-wiki","text":"Seja bem vindo \u00e0 documenta\u00e7\u00e3o do Saturn-GL em portugu\u00eas, a seguir veja alguns exemplos de c\u00f3digo. Fique \u00e0 vontade para alterar e rodar os exemplos encontrados nas caixas interativas de c\u00f3digo abaixo:","title":"Bem vindos \u00e0 Saturn Wiki"},{"location":"#uma-pequena-bolinha-rosa","text":"createCodeBlock('divcode1','1', `Circle circle = CircleBuilder.aCircle() .withCenter(100, 500) .withColor(new Color(200,0,200)) .build(); add(circle); circle.move(500,0,seconds(3)).execute();` );","title":"Uma pequena bolinha rosa:"},{"location":"#uma-explosao","text":"neste exemplo 100 circulos s\u00e3o criados e enviados a partir do centro da tela em dire\u00e7\u00e3o as extremidades s\u00e3o criadas por tanto, 100 tasks s\u00e3o criadas, uma para cada bolinha. createCodeBlock('divcode2','2', `for (int i = 0; i < 100; i++) { Circle circle = CircleBuilder.aCircle() .withCenter(500, 500) .withColor(Color.white) .withRadius(20) .build(); add(circle); var ang = Math.random() * 6.28; var distance = Math.random() * 400; circle.move(distance * Math.cos(ang), distance * Math.sin(ang), seconds(3)) .parallel(wait(seconds(1.5)).andThen(circle.changeColor(new Color(0, 0, 0, 0)))) .executeInBackGround(); }` );","title":"Uma  explos\u00e3o:"},{"location":"docpages/gobject/gobject/","text":"Gobject Gobject: diminui\u00e7\u00e3o de ( Graphical objects ), s\u00e3o literalmente todas as entidades que podem ser escritas em tela, desde as formas mais basicas at\u00e9 as composi\u00e7\u00f5es mais complexas de formas, textos e videos etc... sua apresenta\u00e7\u00e3o cont\u00e9m uma lista de Gobjects, na qual \u00e9 preciso adicionar caso queira que o objeto em quest\u00e3o apare\u00e7a nos frames. Gobject gobject = //algum gobject add ( gobject ); // \u00e9 necessario adicinar para que apare\u00e7a na tela; Tasks de Gobjects move a fun\u00e7\u00e3o move gera um task que vai mover o objeto (x,y) posi\u00e7\u00f5es no espa\u00e7o, \u00e9 possivel determinar o numero de passos passando um terceiro argumento como veremos a seguir: Gobject gobject = //algum gobject gobject . move ( 200 , - 100 ); // 200 unidades \u00e0 direita, 100 para baixo gobject . move ( 200 , - 100 , 30 ); // durante 30 quadros // ou ainda gobject . move ( 200 , - 100 , seconds ( 1.5 )); // durante 1.5 segundos note que seconds(double s) \u00e9 um metodo de presentation que calcula a quantidade de quadros no fps configurado para alcan\u00e7ar o tempo desejado. moveTo a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos rotate a fun\u00e7\u00e3o rotate gera um task que vai girar o objecto em (x) radianos; Gobject gobject = //algum gobject gobject . rotate ( 3.141592 ); // meia volta a direita; gobject . rotate ( - 3.141592 ); // meia volta a esquerda; // se preferir converta graus para radianos gobject . moveTo ( Math . toRadians ( 180 )); // meia volta da mesma maneira // o argumento de duara\u00e7\u00e3o tmb \u00e9 valido aqui gobject . moveTo ( Math . toRadians ( 180 ), seconds ( 2 )); scale a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos Saturn Terminal createCodeBlock('divitest2','4', 'Math.random(20);\\n'+ 'var pepe = new Color(0,0,222);'); Static Math . random ( 20 ); Saturn Terminal2 createCodeBlock('divitest3','3', <code>Math.random(20); var pepe = new Color(0,0,222);</code>); sdakldjlaksjd ksdjalkjdlaksjdla a n","title":"gobject"},{"location":"docpages/gobject/gobject/#gobject","text":"Gobject: diminui\u00e7\u00e3o de ( Graphical objects ), s\u00e3o literalmente todas as entidades que podem ser escritas em tela, desde as formas mais basicas at\u00e9 as composi\u00e7\u00f5es mais complexas de formas, textos e videos etc... sua apresenta\u00e7\u00e3o cont\u00e9m uma lista de Gobjects, na qual \u00e9 preciso adicionar caso queira que o objeto em quest\u00e3o apare\u00e7a nos frames. Gobject gobject = //algum gobject add ( gobject ); // \u00e9 necessario adicinar para que apare\u00e7a na tela;","title":"Gobject"},{"location":"docpages/gobject/gobject/#tasks-de-gobjects","text":"","title":"Tasks de Gobjects"},{"location":"docpages/gobject/gobject/#move","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto (x,y) posi\u00e7\u00f5es no espa\u00e7o, \u00e9 possivel determinar o numero de passos passando um terceiro argumento como veremos a seguir: Gobject gobject = //algum gobject gobject . move ( 200 , - 100 ); // 200 unidades \u00e0 direita, 100 para baixo gobject . move ( 200 , - 100 , 30 ); // durante 30 quadros // ou ainda gobject . move ( 200 , - 100 , seconds ( 1.5 )); // durante 1.5 segundos note que seconds(double s) \u00e9 um metodo de presentation que calcula a quantidade de quadros no fps configurado para alcan\u00e7ar o tempo desejado.","title":"move"},{"location":"docpages/gobject/gobject/#moveto","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos","title":"moveTo"},{"location":"docpages/gobject/gobject/#rotate","text":"a fun\u00e7\u00e3o rotate gera um task que vai girar o objecto em (x) radianos; Gobject gobject = //algum gobject gobject . rotate ( 3.141592 ); // meia volta a direita; gobject . rotate ( - 3.141592 ); // meia volta a esquerda; // se preferir converta graus para radianos gobject . moveTo ( Math . toRadians ( 180 )); // meia volta da mesma maneira // o argumento de duara\u00e7\u00e3o tmb \u00e9 valido aqui gobject . moveTo ( Math . toRadians ( 180 ), seconds ( 2 ));","title":"rotate"},{"location":"docpages/gobject/gobject/#scale","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos Saturn Terminal createCodeBlock('divitest2','4', 'Math.random(20);\\n'+ 'var pepe = new Color(0,0,222);'); Static Math . random ( 20 ); Saturn Terminal2 createCodeBlock('divitest3','3', <code>Math.random(20); var pepe = new Color(0,0,222);</code>);","title":"scale"},{"location":"docpages/gobject/gobject/#sdakldjlaksjd","text":"ksdjalkjdlaksjdla a n","title":"sdakldjlaksjd"},{"location":"docpages/task/paraleltask/","text":"Paralel Task As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir: Construtor com lista Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList ); Construtor com var args Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[] Utilizando os metodo parallel() da interface Task Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList ); Exemplo pr\u00e1tico vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); } Teste voc\u00ea mesmo este exemplo! createCodeBlock('divitest','3', `Circle circle1 = CircleBuilder.aCircle() .withCenter(100, 250) .withColor(Color.red) .build(); Circle circle2 = CircleBuilder.aCircle() .withCenter(400, 100) .withColor(Color.blue) .build(); add(circle1); add(circle2); var task1 = circle1.move(300,0).andThen(circle1.move(-300,0)).repeat(5); var task2 = circle2.move(0,300).andThen(circle2.move(0,-300)).repeat(5); task1.parallel(task2).execute();` );","title":"Parallel Task"},{"location":"docpages/task/paraleltask/#paralel-task","text":"As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir:","title":"Paralel Task"},{"location":"docpages/task/paraleltask/#construtor-com-lista","text":"Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList );","title":"Construtor com lista"},{"location":"docpages/task/paraleltask/#construtor-com-var-args","text":"Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[]","title":"Construtor com var args"},{"location":"docpages/task/paraleltask/#utilizando-os-metodo-parallel-da-interface-task","text":"Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList );","title":"Utilizando os metodo parallel() da interface Task"},{"location":"docpages/task/paraleltask/#exemplo-pratico","text":"vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Exemplo pr\u00e1tico"},{"location":"docpages/task/paraleltask/#teste-voce-mesmo-este-exemplo","text":"createCodeBlock('divitest','3', `Circle circle1 = CircleBuilder.aCircle() .withCenter(100, 250) .withColor(Color.red) .build(); Circle circle2 = CircleBuilder.aCircle() .withCenter(400, 100) .withColor(Color.blue) .build(); add(circle1); add(circle2); var task1 = circle1.move(300,0).andThen(circle1.move(-300,0)).repeat(5); var task2 = circle2.move(0,300).andThen(circle2.move(0,-300)).repeat(5); task1.parallel(task2).execute();` );","title":"Teste voc\u00ea mesmo este exemplo!"},{"location":"docpages/task/task/","text":"Task Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task. Composi\u00e7\u00e3o de Tasks Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 . E se quisessemos executar em paralelo? Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); } Dura\u00e7\u00e3o as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos Zona de c\u00f3digo livre: createCodeBlock('divitest2','4'); Open Modal \u00d7 // Get the modal var modal = document.getElementById(\"myModal\"); createStaticBlock('pepemujica','5',` package graphical.basics.task; import graphical.basics.presentation.Presentation; import java.util.function.Function; import java.util.function.Supplier; public interface Task { void setup(); void step(); boolean isDone(); default Task andThen(Task t2) { if (this instanceof SequenceTask) { ((SequenceTask) this).addTask(t2); return this; } else { return new SequenceTask(this, t2); } } default Task andThen(Supplier<Task> supplier) { return andThen(new ContextSetupTask(supplier)); } default Task parallel(Task t2) { if (this instanceof ParalelTask) { ((ParalelTask) this).addTask(t2); return this; } else { return new ParalelTask(this, t2); } } default Task parallel(Supplier<Task> supplier) { return parallel(new ContextSetupTask(supplier)); } default Task repeat(int times) { return new RepeatTask(times, this); } default Task wait(int steps) { return this.andThen(new WaitTask(steps)); } default Task step(Runnable runnable) { return this.andThen(new SingleStepTask(runnable)); } static void consume(Task task) { task.setup(); while (!task.isDone()) { task.step(); } } default void execute() { Presentation.staticReference.execute(this); } default InterruptableTask executeInBackGround() { return Presentation.staticReference.backGroundTask.append(this); } // // public static <T extends Task> Collector<T, ?, ParalelTask> toList() { // return new Collectors.CollectorImpl(ArrayList::new, List::add, (left, right) -> { // left.addAll(right); // return left; // }, CH_ID); // } } `); // Get the button that opens the modal var btn = document.getElementById(\"myBtn\"); // Get the <span> element that closes the modal var span = document.getElementsByClassName(\"close\")[0]; // When the user clicks on the button, open the modal btn.onclick = function() { modal.style.display = \"block\"; } // When the user clicks on <span> (x), close the modal span.onclick = function() { modal.style.display = \"none\"; } // When the user clicks anywhere outside of the modal, close it window.onclick = function(event) { if (event.target == modal) { modal.style.display = \"none\"; } }","title":"Task"},{"location":"docpages/task/task/#task","text":"Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task.","title":"Task"},{"location":"docpages/task/task/#composicao-de-tasks","text":"Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 .","title":"Composi\u00e7\u00e3o de Tasks"},{"location":"docpages/task/task/#e-se-quisessemos-executar-em-paralelo","text":"Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); }","title":"E se quisessemos executar em paralelo?"},{"location":"docpages/task/task/#duracao","text":"as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos","title":"Dura\u00e7\u00e3o"},{"location":"docpages/task/task/#zona-de-codigo-livre","text":"createCodeBlock('divitest2','4'); Open Modal \u00d7 // Get the modal var modal = document.getElementById(\"myModal\"); createStaticBlock('pepemujica','5',` package graphical.basics.task; import graphical.basics.presentation.Presentation; import java.util.function.Function; import java.util.function.Supplier; public interface Task { void setup(); void step(); boolean isDone(); default Task andThen(Task t2) { if (this instanceof SequenceTask) { ((SequenceTask) this).addTask(t2); return this; } else { return new SequenceTask(this, t2); } } default Task andThen(Supplier<Task> supplier) { return andThen(new ContextSetupTask(supplier)); } default Task parallel(Task t2) { if (this instanceof ParalelTask) { ((ParalelTask) this).addTask(t2); return this; } else { return new ParalelTask(this, t2); } } default Task parallel(Supplier<Task> supplier) { return parallel(new ContextSetupTask(supplier)); } default Task repeat(int times) { return new RepeatTask(times, this); } default Task wait(int steps) { return this.andThen(new WaitTask(steps)); } default Task step(Runnable runnable) { return this.andThen(new SingleStepTask(runnable)); } static void consume(Task task) { task.setup(); while (!task.isDone()) { task.step(); } } default void execute() { Presentation.staticReference.execute(this); } default InterruptableTask executeInBackGround() { return Presentation.staticReference.backGroundTask.append(this); } // // public static <T extends Task> Collector<T, ?, ParalelTask> toList() { // return new Collectors.CollectorImpl(ArrayList::new, List::add, (left, right) -> { // left.addAll(right); // return left; // }, CH_ID); // } } `); // Get the button that opens the modal var btn = document.getElementById(\"myBtn\"); // Get the <span> element that closes the modal var span = document.getElementsByClassName(\"close\")[0]; // When the user clicks on the button, open the modal btn.onclick = function() { modal.style.display = \"block\"; } // When the user clicks on <span> (x), close the modal span.onclick = function() { modal.style.display = \"none\"; } // When the user clicks anywhere outside of the modal, close it window.onclick = function(event) { if (event.target == modal) { modal.style.display = \"none\"; } }","title":"Zona de c\u00f3digo livre:"},{"location":"pt/","text":"Bem vindos \u00e0 Saturn Wiki Seja bem vindo \u00e0 documenta\u00e7\u00e3o do Saturn-GL em portugu\u00eas, a seguir veja alguns exemplos de c\u00f3digo. Fique \u00e0 vontade para alterar e rodar os exemplos encontrados nas caixas interativas de c\u00f3digo abaixo: Uma pequena bolinha rosa: createCodeBlock('divcode1','1', `Circle circle = CircleBuilder.aCircle() .withCenter(100, 500) .withColor(new Color(200,0,200)) .build(); add(circle); circle.move(500,0,seconds(3)).execute();` ); Uma explos\u00e3o: neste exemplo 100 circulos s\u00e3o criados e enviados a partir do centro da tela em dire\u00e7\u00e3o as extremidades s\u00e3o criadas por tanto, 100 tasks s\u00e3o criadas, uma para cada bolinha. createCodeBlock('divcode2','2', `for (int i = 0; i < 100; i++) { Circle circle = CircleBuilder.aCircle() .withCenter(500, 500) .withColor(Color.white) .withRadius(20) .build(); add(circle); var ang = Math.random() * 6.28; var distance = Math.random() * 400; circle.move(distance * Math.cos(ang), distance * Math.sin(ang), seconds(3)) .parallel(wait(seconds(1.5)).andThen(circle.changeColor(new Color(0, 0, 0, 0)))) .executeInBackGround(); }` );","title":"Home"},{"location":"pt/#bem-vindos-a-saturn-wiki","text":"Seja bem vindo \u00e0 documenta\u00e7\u00e3o do Saturn-GL em portugu\u00eas, a seguir veja alguns exemplos de c\u00f3digo. Fique \u00e0 vontade para alterar e rodar os exemplos encontrados nas caixas interativas de c\u00f3digo abaixo:","title":"Bem vindos \u00e0 Saturn Wiki"},{"location":"pt/#uma-pequena-bolinha-rosa","text":"createCodeBlock('divcode1','1', `Circle circle = CircleBuilder.aCircle() .withCenter(100, 500) .withColor(new Color(200,0,200)) .build(); add(circle); circle.move(500,0,seconds(3)).execute();` );","title":"Uma pequena bolinha rosa:"},{"location":"pt/#uma-explosao","text":"neste exemplo 100 circulos s\u00e3o criados e enviados a partir do centro da tela em dire\u00e7\u00e3o as extremidades s\u00e3o criadas por tanto, 100 tasks s\u00e3o criadas, uma para cada bolinha. createCodeBlock('divcode2','2', `for (int i = 0; i < 100; i++) { Circle circle = CircleBuilder.aCircle() .withCenter(500, 500) .withColor(Color.white) .withRadius(20) .build(); add(circle); var ang = Math.random() * 6.28; var distance = Math.random() * 400; circle.move(distance * Math.cos(ang), distance * Math.sin(ang), seconds(3)) .parallel(wait(seconds(1.5)).andThen(circle.changeColor(new Color(0, 0, 0, 0)))) .executeInBackGround(); }` );","title":"Uma  explos\u00e3o:"},{"location":"pt/docpages/gobject/gobject/","text":"Gobject Gobject: diminui\u00e7\u00e3o de ( Graphical objects ), s\u00e3o literalmente todas as entidades que podem ser escritas em tela, desde as formas mais basicas at\u00e9 as composi\u00e7\u00f5es mais complexas de formas, textos e videos etc... sua apresenta\u00e7\u00e3o cont\u00e9m uma lista de Gobjects, na qual \u00e9 preciso adicionar caso queira que o objeto em quest\u00e3o apare\u00e7a nos frames. Gobject gobject = //algum gobject add ( gobject ); // \u00e9 necessario adicinar para que apare\u00e7a na tela; Tasks de Gobjects move a fun\u00e7\u00e3o move gera um task que vai mover o objeto (x,y) posi\u00e7\u00f5es no espa\u00e7o, \u00e9 possivel determinar o numero de passos passando um terceiro argumento como veremos a seguir: Gobject gobject = //algum gobject gobject . move ( 200 , - 100 ); // 200 unidades \u00e0 direita, 100 para baixo gobject . move ( 200 , - 100 , 30 ); // durante 30 quadros // ou ainda gobject . move ( 200 , - 100 , seconds ( 1.5 )); // durante 1.5 segundos note que seconds(double s) \u00e9 um metodo de presentation que calcula a quantidade de quadros no fps configurado para alcan\u00e7ar o tempo desejado. moveTo a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos rotate a fun\u00e7\u00e3o rotate gera um task que vai girar o objecto em (x) radianos; Gobject gobject = //algum gobject gobject . rotate ( 3.141592 ); // meia volta a direita; gobject . rotate ( - 3.141592 ); // meia volta a esquerda; // se preferir converta graus para radianos gobject . moveTo ( Math . toRadians ( 180 )); // meia volta da mesma maneira // o argumento de duara\u00e7\u00e3o tmb \u00e9 valido aqui gobject . moveTo ( Math . toRadians ( 180 ), seconds ( 2 )); scale a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos Saturn Terminal createCodeBlock('divitest2','4', 'Math.random(20);\\n'+ 'var pepe = new Color(0,0,222);'); Static Math . random ( 20 ); Saturn Terminal2 createCodeBlock('divitest3','3', <code>Math.random(20); var pepe = new Color(0,0,222);</code>); sdakldjlaksjd ksdjalkjdlaksjdla a n","title":"gobject"},{"location":"pt/docpages/gobject/gobject/#gobject","text":"Gobject: diminui\u00e7\u00e3o de ( Graphical objects ), s\u00e3o literalmente todas as entidades que podem ser escritas em tela, desde as formas mais basicas at\u00e9 as composi\u00e7\u00f5es mais complexas de formas, textos e videos etc... sua apresenta\u00e7\u00e3o cont\u00e9m uma lista de Gobjects, na qual \u00e9 preciso adicionar caso queira que o objeto em quest\u00e3o apare\u00e7a nos frames. Gobject gobject = //algum gobject add ( gobject ); // \u00e9 necessario adicinar para que apare\u00e7a na tela;","title":"Gobject"},{"location":"pt/docpages/gobject/gobject/#tasks-de-gobjects","text":"","title":"Tasks de Gobjects"},{"location":"pt/docpages/gobject/gobject/#move","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto (x,y) posi\u00e7\u00f5es no espa\u00e7o, \u00e9 possivel determinar o numero de passos passando um terceiro argumento como veremos a seguir: Gobject gobject = //algum gobject gobject . move ( 200 , - 100 ); // 200 unidades \u00e0 direita, 100 para baixo gobject . move ( 200 , - 100 , 30 ); // durante 30 quadros // ou ainda gobject . move ( 200 , - 100 , seconds ( 1.5 )); // durante 1.5 segundos note que seconds(double s) \u00e9 um metodo de presentation que calcula a quantidade de quadros no fps configurado para alcan\u00e7ar o tempo desejado.","title":"move"},{"location":"pt/docpages/gobject/gobject/#moveto","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos","title":"moveTo"},{"location":"pt/docpages/gobject/gobject/#rotate","text":"a fun\u00e7\u00e3o rotate gera um task que vai girar o objecto em (x) radianos; Gobject gobject = //algum gobject gobject . rotate ( 3.141592 ); // meia volta a direita; gobject . rotate ( - 3.141592 ); // meia volta a esquerda; // se preferir converta graus para radianos gobject . moveTo ( Math . toRadians ( 180 )); // meia volta da mesma maneira // o argumento de duara\u00e7\u00e3o tmb \u00e9 valido aqui gobject . moveTo ( Math . toRadians ( 180 ), seconds ( 2 ));","title":"rotate"},{"location":"pt/docpages/gobject/gobject/#scale","text":"a fun\u00e7\u00e3o move gera um task que vai mover o objeto ate a location (x,y) , diferentemente da funtion move que adiciona x, y a posi\u00e7\u00e3o atual. a fun\u00e7\u00e3o move to calcula quantas unidades \u00e9 necessario andar para atingir a location passada. Gobject gobject = //algum gobject gobject . moveTo ( Location . at ( 500 , 500 )); // move para a posicao 500,500 n\u00e3o importa de onde esteja gobject . moveTo ( Location . at ( 500 , 500 ), 30 ); // durante 30 quadros // ou ainda gobject . moveTo ( Location . at ( 500 , 500 ), seconds ( 1.5 )); // durante 1.5 segundos Saturn Terminal createCodeBlock('divitest2','4', 'Math.random(20);\\n'+ 'var pepe = new Color(0,0,222);'); Static Math . random ( 20 ); Saturn Terminal2 createCodeBlock('divitest3','3', <code>Math.random(20); var pepe = new Color(0,0,222);</code>);","title":"scale"},{"location":"pt/docpages/gobject/gobject/#sdakldjlaksjd","text":"ksdjalkjdlaksjdla a n","title":"sdakldjlaksjd"},{"location":"pt/docpages/task/paraleltask/","text":"Paralel Task As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir: Construtor com lista Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList ); Construtor com var args Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[] Utilizando os metodo parallel() da interface Task Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList ); Exemplo pr\u00e1tico vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); } Teste voc\u00ea mesmo este exemplo! createCodeBlock('divitest','3', `Circle circle1 = CircleBuilder.aCircle() .withCenter(100, 250) .withColor(Color.red) .build(); Circle circle2 = CircleBuilder.aCircle() .withCenter(400, 100) .withColor(Color.blue) .build(); add(circle1); add(circle2); var task1 = circle1.move(300,0).andThen(circle1.move(-300,0)).repeat(5); var task2 = circle2.move(0,300).andThen(circle2.move(0,-300)).repeat(5); task1.parallel(task2).execute();` );","title":"Parallel Task"},{"location":"pt/docpages/task/paraleltask/#paralel-task","text":"As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir:","title":"Paralel Task"},{"location":"pt/docpages/task/paraleltask/#construtor-com-lista","text":"Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList );","title":"Construtor com lista"},{"location":"pt/docpages/task/paraleltask/#construtor-com-var-args","text":"Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[]","title":"Construtor com var args"},{"location":"pt/docpages/task/paraleltask/#utilizando-os-metodo-parallel-da-interface-task","text":"Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList );","title":"Utilizando os metodo parallel() da interface Task"},{"location":"pt/docpages/task/paraleltask/#exemplo-pratico","text":"vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Exemplo pr\u00e1tico"},{"location":"pt/docpages/task/paraleltask/#teste-voce-mesmo-este-exemplo","text":"createCodeBlock('divitest','3', `Circle circle1 = CircleBuilder.aCircle() .withCenter(100, 250) .withColor(Color.red) .build(); Circle circle2 = CircleBuilder.aCircle() .withCenter(400, 100) .withColor(Color.blue) .build(); add(circle1); add(circle2); var task1 = circle1.move(300,0).andThen(circle1.move(-300,0)).repeat(5); var task2 = circle2.move(0,300).andThen(circle2.move(0,-300)).repeat(5); task1.parallel(task2).execute();` );","title":"Teste voc\u00ea mesmo este exemplo!"},{"location":"pt/docpages/task/task/","text":"Task Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task. Composi\u00e7\u00e3o de Tasks Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 . E se quisessemos executar em paralelo? Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); } Dura\u00e7\u00e3o as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos Zona de c\u00f3digo livre: createCodeBlock('divitest2','4'); Open Modal \u00d7 // Get the modal var modal = document.getElementById(\"myModal\"); createStaticBlock('pepemujica','5',` package graphical.basics.task; import graphical.basics.presentation.Presentation; import java.util.function.Function; import java.util.function.Supplier; public interface Task { void setup(); void step(); boolean isDone(); default Task andThen(Task t2) { if (this instanceof SequenceTask) { ((SequenceTask) this).addTask(t2); return this; } else { return new SequenceTask(this, t2); } } default Task andThen(Supplier<Task> supplier) { return andThen(new ContextSetupTask(supplier)); } default Task parallel(Task t2) { if (this instanceof ParalelTask) { ((ParalelTask) this).addTask(t2); return this; } else { return new ParalelTask(this, t2); } } default Task parallel(Supplier<Task> supplier) { return parallel(new ContextSetupTask(supplier)); } default Task repeat(int times) { return new RepeatTask(times, this); } default Task wait(int steps) { return this.andThen(new WaitTask(steps)); } default Task step(Runnable runnable) { return this.andThen(new SingleStepTask(runnable)); } static void consume(Task task) { task.setup(); while (!task.isDone()) { task.step(); } } default void execute() { Presentation.staticReference.execute(this); } default InterruptableTask executeInBackGround() { return Presentation.staticReference.backGroundTask.append(this); } // // public static <T extends Task> Collector<T, ?, ParalelTask> toList() { // return new Collectors.CollectorImpl(ArrayList::new, List::add, (left, right) -> { // left.addAll(right); // return left; // }, CH_ID); // } } `); // Get the button that opens the modal var btn = document.getElementById(\"myBtn\"); // Get the <span> element that closes the modal var span = document.getElementsByClassName(\"close\")[0]; // When the user clicks on the button, open the modal btn.onclick = function() { modal.style.display = \"block\"; } // When the user clicks on <span> (x), close the modal span.onclick = function() { modal.style.display = \"none\"; } // When the user clicks anywhere outside of the modal, close it window.onclick = function(event) { if (event.target == modal) { modal.style.display = \"none\"; } }","title":"Task"},{"location":"pt/docpages/task/task/#task","text":"Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task.","title":"Task"},{"location":"pt/docpages/task/task/#composicao-de-tasks","text":"Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 .","title":"Composi\u00e7\u00e3o de Tasks"},{"location":"pt/docpages/task/task/#e-se-quisessemos-executar-em-paralelo","text":"Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); }","title":"E se quisessemos executar em paralelo?"},{"location":"pt/docpages/task/task/#duracao","text":"as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos","title":"Dura\u00e7\u00e3o"},{"location":"pt/docpages/task/task/#zona-de-codigo-livre","text":"createCodeBlock('divitest2','4'); Open Modal \u00d7 // Get the modal var modal = document.getElementById(\"myModal\"); createStaticBlock('pepemujica','5',` package graphical.basics.task; import graphical.basics.presentation.Presentation; import java.util.function.Function; import java.util.function.Supplier; public interface Task { void setup(); void step(); boolean isDone(); default Task andThen(Task t2) { if (this instanceof SequenceTask) { ((SequenceTask) this).addTask(t2); return this; } else { return new SequenceTask(this, t2); } } default Task andThen(Supplier<Task> supplier) { return andThen(new ContextSetupTask(supplier)); } default Task parallel(Task t2) { if (this instanceof ParalelTask) { ((ParalelTask) this).addTask(t2); return this; } else { return new ParalelTask(this, t2); } } default Task parallel(Supplier<Task> supplier) { return parallel(new ContextSetupTask(supplier)); } default Task repeat(int times) { return new RepeatTask(times, this); } default Task wait(int steps) { return this.andThen(new WaitTask(steps)); } default Task step(Runnable runnable) { return this.andThen(new SingleStepTask(runnable)); } static void consume(Task task) { task.setup(); while (!task.isDone()) { task.step(); } } default void execute() { Presentation.staticReference.execute(this); } default InterruptableTask executeInBackGround() { return Presentation.staticReference.backGroundTask.append(this); } // // public static <T extends Task> Collector<T, ?, ParalelTask> toList() { // return new Collectors.CollectorImpl(ArrayList::new, List::add, (left, right) -> { // left.addAll(right); // return left; // }, CH_ID); // } } `); // Get the button that opens the modal var btn = document.getElementById(\"myBtn\"); // Get the <span> element that closes the modal var span = document.getElementsByClassName(\"close\")[0]; // When the user clicks on the button, open the modal btn.onclick = function() { modal.style.display = \"block\"; } // When the user clicks on <span> (x), close the modal span.onclick = function() { modal.style.display = \"none\"; } // When the user clicks anywhere outside of the modal, close it window.onclick = function(event) { if (event.target == modal) { modal.style.display = \"none\"; } }","title":"Zona de c\u00f3digo livre:"}]}