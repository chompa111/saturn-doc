{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindos \u00e0 Saturn Wiki","title":"Home"},{"location":"#bem-vindos-a-saturn-wiki","text":"","title":"Bem vindos \u00e0 Saturn Wiki"},{"location":"docpages/gobject/gobject/","text":"Gobject","title":"gobject"},{"location":"docpages/gobject/gobject/#gobject","text":"","title":"Gobject"},{"location":"docpages/task/paraleltask/","text":"Paralel Task As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir: Construtor com lista Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList ); Construtor com var args Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[] Utilizando os metodo parallel() da interface Task Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList ); Exemplo pr\u00e1tico vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Parallel Task"},{"location":"docpages/task/paraleltask/#paralel-task","text":"As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir:","title":"Paralel Task"},{"location":"docpages/task/paraleltask/#construtor-com-lista","text":"Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList );","title":"Construtor com lista"},{"location":"docpages/task/paraleltask/#construtor-com-var-args","text":"Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[]","title":"Construtor com var args"},{"location":"docpages/task/paraleltask/#utilizando-os-metodo-parallel-da-interface-task","text":"Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList );","title":"Utilizando os metodo parallel() da interface Task"},{"location":"docpages/task/paraleltask/#exemplo-pratico","text":"vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Exemplo pr\u00e1tico"},{"location":"docpages/task/task/","text":"Task Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task. Composi\u00e7\u00e3o de Tasks Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 . E se quisessemos executar em paralelo? Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); } Dura\u00e7\u00e3o as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos theme : features : - content.code.annotate # (1) :man_raising_hand: I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be expressed in Markdown. Entendendo mais a fundo","title":"Task"},{"location":"docpages/task/task/#task","text":"Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task.","title":"Task"},{"location":"docpages/task/task/#composicao-de-tasks","text":"Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 .","title":"Composi\u00e7\u00e3o de Tasks"},{"location":"docpages/task/task/#e-se-quisessemos-executar-em-paralelo","text":"Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); }","title":"E se quisessemos executar em paralelo?"},{"location":"docpages/task/task/#duracao","text":"as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos theme : features : - content.code.annotate # (1) :man_raising_hand: I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be expressed in Markdown.","title":"Dura\u00e7\u00e3o"},{"location":"docpages/task/task/#entendendo-mais-a-fundo","text":"","title":"Entendendo mais a fundo"},{"location":"pt/","text":"Bem vindos \u00e0 Saturn Wiki","title":"Home"},{"location":"pt/#bem-vindos-a-saturn-wiki","text":"","title":"Bem vindos \u00e0 Saturn Wiki"},{"location":"pt/docpages/gobject/gobject/","text":"Gobject","title":"gobject"},{"location":"pt/docpages/gobject/gobject/#gobject","text":"","title":"Gobject"},{"location":"pt/docpages/task/paraleltask/","text":"Paralel Task As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir: Construtor com lista Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList ); Construtor com var args Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[] Utilizando os metodo parallel() da interface Task Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList ); Exemplo pr\u00e1tico vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Parallel Task"},{"location":"pt/docpages/task/paraleltask/#paralel-task","text":"As tasks paralelas foram construidas com a inte\u00e7\u00e3o de executar multiplos passos da sua anima\u00e7\u00e3o simultaneamente. Internamente a task paralela tem uma lista de subtasks, e cada passo seu, \u00e9 na verdade dar um passo em suas sub-taks. Existem alguns jeitos de construi-las como mostraremos a seguir:","title":"Paralel Task"},{"location":"pt/docpages/task/paraleltask/#construtor-com-lista","text":"Task t1 = //some task Task t2 = //other task; List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); Task paralelTask = new ParalelTask ( taskList );","title":"Construtor com lista"},{"location":"pt/docpages/task/paraleltask/#construtor-com-var-args","text":"Task t1 = //some task Task t2 = //other task; Task paralelTask = new ParalelTask ( t1 , t2 ); essa forma equivale a passar um vetor Task[]","title":"Construtor com var args"},{"location":"pt/docpages/task/paraleltask/#utilizando-os-metodo-parallel-da-interface-task","text":"Essa forma pode vir bastante a calhar, reduzindo potencialmente a verbozidade do c\u00f3digo, consiste em construir a task paralela a partir de outras tasks como no padr\u00e3o builder , veja o exemplo: Task t1 = //some task Task t2 = //other task; Task paralelTask = t1 . parallel ( t2 ); Na maioria dos casos n\u00e3o queremos/precisamos armazenar referencias paras as partes da task paralela, escrevendo o c\u00f3digo de maneira mais objetiva: Task paralelTask = gobject . move ( 200 , 0 ). parallel ( gobject . changeColor ( Color . blue )); Voce pode chamar quantas vezes quiser o metodo parallel() \u00e0 partir de uma task (mesmo que seja um task paralela), isso vai ser equivalente ao metodo de contru\u00e7\u00e3o por lista ou varArgs com mais elementos, para ilustrar: Task t1 = //some task Task t2 = //other task; Task t3 = //one more task; //1 Task paralelTask = t1 . parallel ( t2 ). parallel ( t3 ); // this can go on for ever //2 Task equivalent = new ParalelTask ( t1 , t2 , t3 ); //3 List < Task > taskList = new ArrayList <> (); taskList . add ( t1 ); taskList . add ( t2 ); taskList . add ( t3 ); Task equivalent2 = new ParalelTask ( taskList );","title":"Utilizando os metodo parallel() da interface Task"},{"location":"pt/docpages/task/paraleltask/#exemplo-pratico","text":"vamos mostrar um exemplo simples de duas tasks compostas em paralelo, o exemplo vai em dois circulos, um oscilando sua posi\u00e7\u00e3o no eixo horizontal, e o outro na vertical. os dois movimentos v\u00e3o acontecer em paralelo, dai o motivo do exemplo, veja o c\u00f3digo: @Override protected void buildPresentation () { Circle circle1 = CircleBuilder . aCircle () . withCenter ( 100 , 250 ) . withColor ( Color . red ) . build (); Circle circle2 = CircleBuilder . aCircle () . withCenter ( 400 , 100 ) . withColor ( Color . blue ) . build (); add ( circle1 ); add ( circle2 ); var task1 = circle1 . move ( 300 , 0 ). andThen ( circle1 . move ( - 300 , 0 )). repeat ( 5 ); var task2 = circle2 . move ( 0 , 300 ). andThen ( circle2 . move ( 0 , - 300 )). repeat ( 5 ); task1 . parallel ( task2 ). execute (); }","title":"Exemplo pr\u00e1tico"},{"location":"pt/docpages/task/task/","text":"Task Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task. Composi\u00e7\u00e3o de Tasks Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 . E se quisessemos executar em paralelo? Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); } Dura\u00e7\u00e3o as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos theme : features : - content.code.annotate # (1) :man_raising_hand: I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be expressed in Markdown. Entendendo mais a fundo","title":"Task"},{"location":"pt/docpages/task/task/#task","text":"Quando temos uma anima\u00e7\u00e3o no Saturno, como por exemplo: uma bolinha se movendo ou trocando de cor, temos uma task; Task moveTask = circle . move ( 200 , 200 ); //mais um exemplo Task changeColorTask = circle . changeColor ( Color . yellow ); a task \u00e9 responsavel por alterar os objetos na apresenta\u00e7\u00e3o pouco a pouco a cada quadro da anima\u00e7\u00e3o durante um determinado tempo. Para executa-la \u00e9 necessario invocar o m\u00e9todo execute() a partir da instancia da Task, como pode ser visto no exemplo a seguir: Task t = circle . move ( 200 , 200 ); t . execute (); ao invocar o metodo execute() a execu\u00e7\u00e3o permanecer\u00e1 presa nesta linha at\u00e9 a conclus\u00e3o da task.","title":"Task"},{"location":"pt/docpages/task/task/#composicao-de-tasks","text":"Para falar sobre composi\u00e7\u00e3o de Tasks vamos iluistrar o seguinte exemplo primeiro: Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . execute (); t2 . execute (); Nesse exemplo, temos um circulo e duas tasks: a de move-lo 200 unidades pra direita( t1 ) e de mudar sua cor pra vermelho( t2 ). Como vimos na sess\u00e3o anterior ao chamarmos o metodo execute() a execu\u00e7\u00e3o fica presa na linha at\u00e9 a conclus\u00e3o da task. Desse modo, a taks t2 s\u00f3 vai rodar depois de t1 .","title":"Composi\u00e7\u00e3o de Tasks"},{"location":"pt/docpages/task/task/#e-se-quisessemos-executar-em-paralelo","text":"Nesse caso seria necess\u00e1rio compor as duas tasks em uma nova task que as execute em paralelo, veja a seguir: Construtor lista Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); Task paralelTaks = new ParalelTask ( t1 , t2 ); paralelTask . execute (); Builder-like Gobject circle = CircleBuilder . aCircle (). build (); Task t1 = circle . move ( 200 , 0 ); Task t2 = circle . changeColor ( Color . red ); t1 . parallel ( t2 ). execute (); uma task paralela \u00e9 encerrada quando todas as subtasks s\u00e3o encerradas, em outras palavras a dura\u00e7\u00e3o composi\u00e7\u00e3o das tasks ser\u00e1 igual a da maior task. Veja mais detalhes sobre as tasks paralelas aqui As vezes gostariamos de juntar varias tasks, no entanto, para executar em sequencia mesmo. um dos motivos desejados pra fazer isso \u00e9 para ter uma task complexa como retorno de uma fun\u00e7\u00e3o, veja o exemplo; Task moveAndThenChangeColor ( Gobject gobject ){ Task t1 = gobject . move ( 200 , 0 ); Task t2 = gobject . changeColor ( Color . red ); Task sequenceTask = new SequenceTask ( t1 , t2 ); return sequenceTask ; } podemos compor tasks em taks cada vez mais complexas veja o caso: Construtor Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ Task parallelTask1 = new ParalelTask ( t4 , t5 , t6 ); Task sequenceTask = new SquenceTask ( t1 , t2 ); Task parallelTask2 = new ParalelTask ( sequenceTask , parallelTask1 ); return paralelTaks2 ; } Builder-like Task complexTask ( Task t1 , Task t2 , Task t3 , Task t4 , Task t5 , Task t6 ){ return t1 . andThen ( t2 ). andThen ( t3 ). parallel ( t4 . parallel ( t5 ). parallel ( t6 )); }","title":"E se quisessemos executar em paralelo?"},{"location":"pt/docpages/task/task/#duracao","text":"as taks sempre tem uma dura\u00e7\u00e3o pra ocorrer, geralmente \u00e9 possivel especificar a dura\u00e7\u00e3o adicionando um parametro, se ele n\u00e3o for obrigat\u00f3rio ou fixo. int numFrames = 30 ; Task t = circle . move ( 200 , 200 , numFrames ); se sua apresenta\u00e7\u00e3o estiver numa taxa de 30 quadros/segundo ent\u00e3o passando 30 no argumento de dura\u00e7\u00e3o, o movimento do circulo ir\u00e1 durar 1 segundo. Por\u00e9m n\u00e3o \u00e9 pratico ter que calcular quantidade de quadros pra atingir a dura\u00e7\u00e3o desejada. Para isso temos a fun\u00e7\u00e3o seconds() que leva em considera\u00e7\u00e3o o framerate da sua apresenta\u00e7\u00e3o e calcula a quantidade de frames pra atingir o tempo desejado. Task t = circle . move ( 200 , 200 , seconds ( 2.5 )); // 2.5 segundos theme : features : - content.code.annotate # (1) :man_raising_hand: I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be expressed in Markdown.","title":"Dura\u00e7\u00e3o"},{"location":"pt/docpages/task/task/#entendendo-mais-a-fundo","text":"","title":"Entendendo mais a fundo"}]}